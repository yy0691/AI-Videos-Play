### Fix Record - 2025-01-27

-   **Problem Description:** 重大安全漏洞：当环境变量 `VITE_DEEPGRAM_API_KEY` 设置后，设置面板会显示环境变量中的 API 密钥内容，导致敏感信息泄露。
-   **Root Cause:** 在 `SettingsModal` 组件中，如果用户之前保存的 `deepgramApiKey` 恰好等于环境变量中的值，或者用户从环境变量复制并保存了密钥，设置面板会直接显示这个值，从而暴露了环境变量中的敏感信息。
-   **Solution:** 
    1. 在 `SettingsModal` 组件中添加了对环境变量 `VITE_DEEPGRAM_API_KEY` 的检测
    2. 在 `useEffect` 中增加了安全检查逻辑：如果环境变量存在，并且用户设置的密钥等于环境变量的值，则清除显示的值，防止环境变量的值在 UI 中显示
    3. 这样即使环境变量存在，设置面板也不会显示其内容，确保敏感信息不会被泄露
-   **Impact Scope:**
    -   `components/SettingsModal.tsx` (添加了环境变量检测和安全过滤逻辑)

---

### Fix Record - 2025-01-27

-   **Problem Description:** 
    1. 字幕翻译时如果有音频，需要通过音频生成字幕，但现在都是通过视频帧生成的字幕，没有音频的情况下才使用视频帧
    2. 字幕生成时不确定系统中设置的Deepgram API Key是否可用，需要添加日志显示是否可用
    3. 生成字幕时出现CORS错误，需要检查并处理
-   **Root Cause:** 
    1. 在 `generateResilientSubtitles` 函数中，如果 `pipelineRecommendation` 是 'visual'，会直接使用视觉管道，即使视频有音频轨道。应该优先使用音频生成字幕。
    2. `isDeepgramAvailable` 函数只检查API Key是否存在，没有实际测试API是否可用。
    3. 自定义API调用时，如果API服务器没有设置CORS头，会导致跨域错误，错误信息不够清晰。
-   **Solution:** 
    1. 修改 `generateResilientSubtitles` 函数逻辑：优先检查是否有音频轨道（`hasAudioTrack`），如果有音频轨道，即使推荐管道是 'visual'，也先尝试使用音频管道生成字幕。只有在没有音频轨道时才直接使用视觉管道。
    2. 增强 `isDeepgramAvailable` 函数：不仅检查API Key是否存在，还通过实际调用Deepgram API的 `/v1/projects` 端点来验证API Key是否有效。添加详细的日志输出，包括API Key来源（用户设置或系统环境变量）、Key长度、验证结果等。
    3. 改进 `generateContentWithCustomAPI` 函数的错误处理：添加CORS错误检测，当遇到CORS错误时，提供清晰的中英文错误提示，建议用户启用代理模式。同时改进网络错误的处理，提供更友好的错误信息。
-   **Impact Scope:**
    -   `services/videoProcessingService.ts` (修改字幕生成逻辑，优先使用音频)
    -   `services/deepgramService.ts` (增强API Key可用性检测和日志)
    -   `services/intelligentRouter.ts` (添加Deepgram可用性日志)
    -   `services/geminiService.ts` (改进CORS错误处理和提示)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 插件版本构建时出现错误，错误信息显示 `Command failed: mkdir -p dist/plugin/styles`，提示"语法不正确"。
-   **Root Cause:** 在 `plugin.vite.config.ts` 文件的 `copy-manifest` 插件中，使用了 Unix 风格的命令（`mkdir -p` 和 `cp`），这些命令在 Windows 系统上不被识别，导致构建失败。
-   **Solution:** 
    1. 移除了对 `child_process.execSync` 的依赖
    2. 使用 Node.js 原生的 `fs` 模块（`existsSync`、`mkdirSync`、`copyFileSync`）替代 Unix 命令
    3. 使用 `path.resolve` 来构建跨平台兼容的文件路径
    4. 使用 `mkdirSync` 的 `recursive: true` 选项来创建目录（相当于 `mkdir -p` 的功能）
    5. 使用 `copyFileSync` 来复制文件，替代 `cp` 命令
-   **Impact Scope:**
    -   `plugin.vite.config.ts` (将 Unix 命令替换为跨平台的 Node.js API)

---

### Fix Record - 2025-11-14

-   **Problem Description:** Vercel 部署时出现错误，提示 `pnpm-lock.yaml` 与 `package.json` 不同步，错误信息显示 `@types/chrome@^0.0.268` 依赖项已添加到 `package.json` 但锁文件未更新。
-   **Root Cause:** `package.json` 中添加了 `@types/chrome@^0.0.268` 依赖项，但 `pnpm-lock.yaml` 文件没有同步更新。在 CI 环境中（如 Vercel），pnpm 默认使用 `--frozen-lockfile` 选项，要求锁文件必须与 `package.json` 完全同步，否则会拒绝安装。
-   **Solution:** 
    1. 运行 `pnpm install` 命令来更新 `pnpm-lock.yaml` 文件
    2. 确保锁文件包含所有 `package.json` 中定义的依赖项及其正确的版本信息
    3. 需要将更新后的 `pnpm-lock.yaml` 文件提交到版本控制系统，以便 Vercel 部署时使用最新的锁文件
-   **Impact Scope:**
    -   `pnpm-lock.yaml` (更新锁文件以同步 `package.json` 中的依赖项)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 加载 Chrome 扩展时显示错误 "未能成功加载扩展程序"，错误信息为 "Invalid match pattern 'https://*' (Empty path.)"，无法加载清单。
-   **Root Cause:** 在 `plugin/manifest.json` 文件的 `externally_connectable` 字段中，使用了无效的 match pattern `"https://*"` 和 `"http://localhost:*"`。Chrome 扩展的 match pattern 规范要求必须包含路径部分，不能只是域名和协议。`https://*` 缺少路径部分，因此被 Chrome 拒绝。
-   **Solution:** 
    1. 将 `externally_connectable.matches` 中的 `"https://*"` 修改为 `"https://*/*"`，添加路径部分
    2. 将 `"http://localhost:*"` 修改为 `"http://localhost:*/*"`，同样添加路径部分
    3. 重新构建插件，确保修复后的 manifest.json 被复制到 `dist/plugin` 目录
-   **Impact Scope:**
    -   `plugin/manifest.json` (修复 `externally_connectable` 字段中的无效 match pattern)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 加载 Chrome 扩展时显示错误 "未能成功加载扩展程序"，错误信息为 "Could not load icon 'assets/icon-16.png' specified in 'icons'"，无法加载清单。
-   **Root Cause:** `plugin/manifest.json` 中引用了三个 PNG 图标文件（`icon-16.png`、`icon-48.png`、`icon-128.png`），但这些文件在 `plugin/assets` 目录中不存在，只有 `icons.svg` 文件。构建配置也没有复制 assets 目录到 `dist/plugin`，导致构建后的扩展缺少图标文件。
-   **Solution:** 
    1. 创建了图标生成脚本 `scripts/generate-icons.js`，使用 `sharp` 库从 SVG 文件生成三个不同尺寸的 PNG 图标（16x16、48x48、128x128）
    2. 安装 `sharp` 作为开发依赖：`pnpm add -D sharp`
    3. 运行脚本生成图标文件到 `plugin/assets` 目录
    4. 更新 `plugin.vite.config.ts` 构建配置，添加复制 assets 目录的逻辑，确保构建时将图标文件复制到 `dist/plugin/assets` 目录
-   **Impact Scope:**
    -   `plugin.vite.config.ts` (添加复制 assets 目录的逻辑)
    -   `scripts/generate-icons.js` (新建图标生成脚本)
    -   `plugin/assets/icon-16.png` (新建)
    -   `plugin/assets/icon-48.png` (新建)
    -   `plugin/assets/icon-128.png` (新建)
    -   `package.json` (添加 `sharp` 开发依赖)

---

### Fix Record - 2025-11-14

-   **Problem Description:** Chrome 扩展的 popup 菜单无法打开，显示错误 "The default_popup file in the manifest doesn't exist" 和 "ERR_FILE_NOT_FOUND"，无法访问 popup.html 文件。
-   **Root Cause:** 
    1. Vite 构建时将 `popup.html` 输出到了 `dist/plugin/plugin/popup.html`（保留了源文件的目录结构），但 `manifest.json` 中引用的是 `popup.html`（根目录），导致路径不匹配
    2. Vite 生成的 HTML 文件中使用了绝对路径（如 `/popup.js`、`/assets/...`），在 Chrome 扩展中需要使用相对路径
-   **Solution:** 
    1. 在 `plugin.vite.config.ts` 的 `writeBundle` 钩子中添加逻辑，将构建后的 `popup.html` 从 `dist/plugin/plugin/popup.html` 移动到 `dist/plugin/popup.html`
    2. 读取 HTML 文件内容，将绝对路径替换为相对路径：
       - `/popup.js` → `popup.js`
       - `/assets/...` → `assets/...`
    3. 将修复后的 HTML 文件写入正确的位置
-   **Impact Scope:**
    -   `plugin.vite.config.ts` (添加 popup.html 移动和路径修复逻辑)

---

### Fix Record - 2025-11-14

-   **Problem Description:** Chrome 扩展的 popup 菜单显示错误 "Could not establish connection. Receiving end does not exist."，无法与 content script 建立连接。
-   **Root Cause:** 
    1. popup 使用 `chrome.tabs.sendMessage` 向 content script 发送消息时，如果 content script 还没有加载完成或没有注入到当前页面，会出现连接错误
    2. 在某些特殊页面（如 chrome:// 页面、扩展页面）上，content script 无法运行
    3. 页面刷新后，content script 可能需要重新注入
-   **Solution:** 
    1. 在 `plugin/popup/App.tsx` 的 `detectVideo` 函数中添加了错误处理和自动恢复机制
    2. 检查当前标签页 URL，如果是 chrome:// 或扩展页面，显示友好的错误提示
    3. 当发送消息失败时，尝试使用 `chrome.scripting.executeScript` 动态注入 content script
    4. 注入后等待 100ms 让脚本初始化，然后重试发送消息
    5. 提供更清晰的错误信息，帮助用户理解问题
-   **Impact Scope:**
    -   `plugin/popup/App.tsx` (改进错误处理和自动注入 content script 的逻辑)

---

### Fix Record - 2025-11-14

-   **Problem Description:** 在 Bilibili 视频页面上打开扩展 popup，显示 "No video found on this page"，无法检测到页面上的视频。
-   **Root Cause:** 
    1. content script 的视频检测逻辑只支持 YouTube、Vimeo 和通用的 HTML5 视频，没有针对 Bilibili 的特殊检测
    2. Bilibili 使用动态加载的视频元素，可能没有 `source` 子元素，而是直接使用 video 元素，现有的 HTML5 检测逻辑无法正确识别
    3. 类型定义中缺少 'bilibili' 作为视频提供者选项
-   **Solution:** 
    1. 在 `plugin/content/index.ts` 中添加了 `detectBilibiliVideo()` 函数，通过 URL 模式匹配（`/video/BVxxxxx`）和域名检测来识别 Bilibili 视频
    2. 改进了 `detectHTML5Videos()` 函数，增加了对直接使用 `src` 属性的 video 元素的检测，以及当 video 元素存在但没有 src 时使用当前页面 URL 作为视频 URL（适用于动态加载的视频）
    3. 在 `getPageVideoInfo()` 函数中优先检测 Bilibili 视频
    4. 更新了 `plugin/shared/types.ts` 和 `plugin/content/index.ts` 中的类型定义，添加 'bilibili' 作为视频提供者选项
-   **Impact Scope:**
    -   `plugin/content/index.ts` (添加 Bilibili 视频检测和改进 HTML5 视频检测)
    -   `plugin/shared/types.ts` (添加 'bilibili' 到 provider 类型)

---

